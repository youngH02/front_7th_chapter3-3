## 과제 체크포인트

### 기본과제

#### 목표 : 전역상태관리를 이용한 적절한 분리와 계층에 대한 이해를 통한 FSD 폴더 구조 적용하기

- 전역상태관리를 사용해서 상태를 분리하고 관리하는 방법에 대한 이해
- Context API, Jotai, Zustand 등 상태관리 라이브러리 사용하기
- FSD(Feature-Sliced Design)에 대한 이해
- FSD를 통한 관심사의 분리에 대한 이해
- 단일책임과 역할이란 무엇인가?
- 관심사를 하나만 가지고 있는가?
- 어디에 무엇을 넣어야 하는가?

#### 체크포인트

- [x] 전역상태관리를 사용해서 상태를 분리하고 관리했나요?
- [x] Props Drilling을 최소화했나요?
- [x] shared 공통 컴포넌트를 분리했나요?
- [x] shared 공통 로직을 분리했나요?
- [x] entities를 중심으로 type을 정의하고 model을 분리했나요?
- [x] entities를 중심으로 ui를 분리했나요?
- [x] entities를 중심으로 api를 분리했나요?
- [x] feature를 중심으로 사용자행동(이벤트 처리)를 분리했나요?
- [x] feature를 중심으로 ui를 분리했나요?
- [x] feature를 중심으로 api를 분리했나요?
- [x] widget을 중심으로 데이터를 재사용가능한 형태로 분리했나요?

### 심화과제

#### 목표: 서버상태관리 도구인 TanstackQuery를 이용하여 비동기코드를 선언적인 함수형 프로그래밍으로 작성하기

- TanstackQuery의 사용법에 대한 이해
- TanstackQuery를 이용한 비동기 코드 작성에 대한 이해
- 비동기 코드를 선언적인 함수형 프로그래밍으로 작성하는 방법에 대한 이해

#### 체크포인트

- [x] 모든 API 호출이 TanStack Query의 useQuery와 useMutation으로 대체되었는가?
- [x] 쿼리 키가 적절히 설정되었는가?
- [x] fetch와 useState가 아닌 선언적인 함수형 프로그래밍이 적절히 적용되었는가?
- [x] 캐싱과 리프레시 전략이 올바르게 구현되었는가?
- [x] 낙관적인 업데이트가 적용되었는가?
- [x] 에러 핸들링이 적절히 구현되었는가?
- [x] 서버 상태와 클라이언트 상태가 명확히 분리되었는가?
- [x] 코드가 간결하고 유지보수가 용이한 구조로 작성되었는가?
- [x] TanStack Query의 Devtools가 정상적으로 작동하는가?

### 최종과제

- [x] 폴더구조와 나의 멘탈모데일이 일치하나요?
- [x] 다른 사람이 봐도 이해하기 쉬운 구조인가요?

## 과제 셀프회고
https://youngh02.github.io/front_7th_chapter3-3/

### 이번 과제를 통해 이전에 비해 새롭게 알게 된 점이 있다면 적어주세요.

**FSD 아키텍처의 계층적 사고방식**

- 기존에는 기능별로만 폴더를 나눴다면, FSD는 "역할"과 "의존성 방향"을 기준으로 구조화한다는 점이 새로웠습니다.
- shared → entities → features → widgets → pages 순서로 의존성이 단방향으로 흐르면서 코드의 예측 가능성이 높아진다는 것을 체감했습니다.

**전역 상태관리의 필요성과 적절한 사용**

- Zustand를 사용하면서 모든 상태를 전역으로 관리할 필요가 없다는 것을 깨달았습니다.
- Dialog 열림/닫힘 같은 UI 상태는 전역으로, 폼 입력값 같은 로컬 상태는 컴포넌트 내부에서 관리하는 것이 더 효율적이었습니다.

**관심사 분리의 실질적인 효과**

- API 로직(entities/api), 비즈니스 로직(features/model), UI(features/ui)를 분리하니 각 파일의 책임이 명확해졌습니다.
- 특히 타입 정의를 entities에 모아두니 여러 곳에서 재사용하기 편했고, 타입 변경 시 영향 범위를 쉽게 파악할 수 있었습니다.

### 본인이 과제를 하면서 가장 애쓰려고 노력했던 부분은 무엇인가요?

**각 레이어의 경계를 명확히 하기**

- features가 entities만 참조하고, entities가 shared만 참조하도록 의존성 규칙을 지키려고 노력했습니다.
- 처음에는 features에서 다른 features를 참조하고 싶은 유혹이 있었지만, 공통 로직은 entities나 shared로 내리는 방식으로 해결했습니다.

**컴포넌트의 단일 책임 원칙 적용**

- 하나의 큰 컴포넌트를 여러 개의 작은 컴포넌트로 분리하면서, 각 컴포넌트가 "하나의 일"만 하도록 만들려고 했습니다.
- 예를 들어 PostCard는 게시글 표시만, AddPostDialog는 게시글 추가 폼만 담당하도록 분리했습니다.

**재사용 가능한 공통 컴포넌트 설계**

- shared/ui에 Button, Dialog, Input 등 기본 UI 컴포넌트를 만들 때, 다양한 상황에서 사용할 수 있도록 props를 유연하게 설계하려고 노력했습니다.
- 특정 기능에 종속되지 않도록 순수하게 UI 역할만 하도록 만들었습니다.

### 아직은 막연하다거나 더 고민이 필요한 부분을 적어주세요.

**FSD의 실용성과 오버엔지니어링 사이의 균형**

- 작은 기능 하나를 추가하는데도 여러 폴더와 파일을 만들어야 해서, 프로젝트 규모에 따라 오히려 복잡도가 증가하는 것은 아닌지 고민됩니다.
- 실무에서는 팀 규모, 프로젝트 크기, 개발 기간 등을 고려해 FSD를 얼마나 엄격하게 적용할지 판단이 필요할 것 같습니다.

**entities와 features의 경계**

- CRUD 중 Read는 entities, CUD는 features에 둔다는 기준은 이해했지만, 복잡한 비즈니스 로직이 섞인 경우 어디에 둬야 할지 애매한 상황이 있었습니다.
- 예를 들어 "조회 + 필터링 + 정렬"이 함께 있는 경우, 어디까지가 entities의 책임이고 어디서부터가 features의 책임인지 명확한 기준을 세우기 어려웠습니다.

**widgets 레이어의 활용**

- widgets를 "여러 features를 조합한 복합 컴포넌트"로 이해했지만, 실제로 언제 widgets를 만들고 언제 features만으로 충분한지 판단 기준이 아직 명확하지 않습니다.
- 프로젝트가 커지면서 자연스럽게 필요성을 느낄 것 같지만, 현재는 조금 추상적으로 느껴집니다.

### 이번에 배운 내용 중을 통해 앞으로 개발에 어떻게 적용해보고 싶은지 적어주세요.

**점진적인 FSD 도입**

- 새 프로젝트를 시작할 때 처음부터 완벽한 FSD 구조를 만들기보다는, shared와 entities부터 시작해서 프로젝트가 성장하면서 features, widgets를 추가하는 방식으로 적용해보고 싶습니다.
- 기존 프로젝트에도 한 번에 전체를 리팩토링하기보다는, 새로운 기능을 추가할 때 FSD 구조로 만들어가는 점진적 접근을 시도해보고 싶습니다.

**팀 컨벤션으로 발전시키기**

- FSD의 핵심 원칙(단방향 의존성, 관심사 분리, 계층화)을 팀원들과 공유하고, 우리 팀에 맞는 폴더 구조 가이드를 만들어보고 싶습니다.
- 특히 "어디에 무엇을 둘 것인가"에 대한 명확한 기준을 문서화해서 팀원 간 일관성을 유지하고 싶습니다.

**상태관리 전략 수립**

- 전역 상태(Zustand), 서버 상태(TanStack Query), 로컬 상태(useState)를 언제 사용할지 명확한 기준을 세우고 싶습니다.
- 이번 과제에서 배운 "상태의 성격에 따른 분리"를 실무에서도 일관되게 적용해보고 싶습니다.

**컴포넌트 설계 원칙 내재화**

- 단일 책임 원칙, 재사용 가능성, 테스트 용이성을 고려한 컴포넌트 설계를 습관화하고 싶습니다.
- 코드 리뷰 시에도 "이 컴포넌트의 책임은 무엇인가?", "의존성 방향이 올바른가?"를 체크하는 관점을 가지고 싶습니다.

## 챕터 셀프회고

> 클린코드와 아키테쳑 챕터 함께 하느라 고생 많으셨습니다!
> 지난 3주간의 여정을 돌이켜 볼 수 있도록 준비해보았습니다.
> 아래에 적힌 질문들은 추억(?)을 회상할 수 있도록 도와주려고 만든 질문이며, 꼭 질문에 대한 대답이 아니어도 좋으니 내가 느꼈던 인사이트들을 자유롭게 적어주세요.

### 클린코드: 읽기 좋고 유지보수하기 좋은 코드 만들기

- 더티코드를 접했을 때 어떤 기분이었나요? ^^; 클린코드의 중요성, 읽기 좋은 코드란 무엇인지, 유지보수하기 쉬운 코드란 무엇인지에 대한 생각을 공유해주세요

### 결합도 낮추기: 디자인 패턴, 순수함수, 컴포넌트 분리, 전역상태 관리

- 거대한 단일 컴포넌트를 봤을때의 느낌! 처음엔 막막했던 상태관리, 디자인 패턴이라는 말이 어렵게만 느껴졌던 시절, 순수함수로 분리하면서 "아하!"했던 순간, 컴포넌트가 독립적이 되어가는 과정에서의 깨달음을 들려주세요

### 응집도 높이기: 서버상태관리, 폴더 구조

"이 코드는 대체 어디에 둬야 하지?"라는 고민이 가장 많았던 부분입니다. 처음에는 FSD의 레이어 구조가 복잡하게 느껴졌지만, 단방향 의존성 규칙을 이해하고 나니 코드 배치가 명확해졌습니다.

**FSD 의존성 규칙 (단방향)**

- pages → widgets, features, entities, shared
- widgets → features, entities, shared
- features → entities, shared
- entities → shared
- shared → 외부 라이브러리만

**실제 적용 예시: add-post 기능**

```
src/
├── shared/
│   ├── ui/
│   │   ├── Button.tsx        ←  버튼 UI
│   │   ├── Dialog.tsx        ←  다이얼로그 UI
│   │   ├── Input.tsx         ←  입력 UI
│   │   └── Card.tsx          ←  Textarea 포함
│   ├── api/
│   │   └── apiClient.ts      ←  fetch 래퍼
│   └── store/
│       └── dialogStore.ts    ←  다이얼로그 상태 관리
│
├── entities/
│   └── posts/
│       ├── model/
│       │   └── types.ts      ←  Post 타입 정의
│       └── api/
│           └── postApi.ts    ←  createPost API 함수
│
├── widgets/
│   └── AddPostDialog/
│       └── index.tsx         ←  게시물 추가 위젯
│
└── pages/
    └── PostsManagerPage.tsx  ←  AddPostDialog 사용
```

| 레이어       | 개수 | 역할                  |
| ------------ | ---- | --------------------- |
| shared/ui    | 4개  | 기본 UI 컴포넌트      |
| shared/api   | 1개  | API 클라이언트        |
| shared/store | 1개  | 다이얼로그 상태 관리  |
| entities     | 2개  | 타입 + API            |
| widgets      | 1개  | 게시물 추가 복합 위젯 |
| pages        | 1개  | 사용                  |

**FSD CRUD 분류 기준**

| 작업          | 레이어   | 이유                                |
| ------------- | -------- | ----------------------------------- |
| Read (조회)   | entities | 단순 데이터 가져오기, 상호작용 없음 |
| Create (생성) | features | 폼 입력, 제출 버튼 등 상호작용      |
| Update (수정) | features | 폼 입력, 제출 버튼 등 상호작용      |
| Delete (삭제) | features | 삭제 확인, 버튼 클릭 등 상호작용    |

 핵심 기준: "상호작용이 있는가?"

**entities (데이터 중심)**

- "이 데이터는 무엇인가?" → types.ts
- "이 데이터를 어떻게 가져오나?" → api/
- "이 데이터를 어떻게 보여주나?" → ui/ (순수 표시)

**features (액션 중심)**

- "사용자가 폼에 입력" → 상호작용
- "사용자가 버튼 클릭" → 상호작용
- "확인/취소 선택" → 상호작용

## 리뷰 받고 싶은 내용이나 궁금한 것에 대한 질문

1. FSD를 실제로 사용하고 계신지, 개인적인 선호도가 어떻게 되시는지 궁금합니다.
2. 프로젝트 규모에 따라 FSD 적용 수준을 조절하는 기준이 있을까요?
3. entities와 features의 경계가 애매한 경우 어떻게 판단하시나요?
